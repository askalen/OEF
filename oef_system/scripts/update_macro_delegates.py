#!/usr/bin/env python3
"""
Generate macro delegates for OEFSnowflake adapter.
This script extracts actual macro implementations from dbt-snowflake 
and creates oefsnowflake versions.

Run this script when updating dbt-snowflake to ensure all macros are properly implemented.
"""

import os
import re
from pathlib import Path

def extract_snowflake_macros():
    """Extract complete Snowflake macro implementations."""
    try:
        import dbt.include.snowflake
        snowflake_path = Path(dbt.include.snowflake.__file__).parent
    except ImportError:
        print("Error: dbt-snowflake must be installed")
        return []
    
    macros = []
    
    # Define the macro pattern once
    macro_pattern = re.compile(
        r'({%\s*macro\s+(\w+)\s*\([^)]*\)\s*%}.*?{%\s*endmacro\s*%})',
        re.DOTALL | re.MULTILINE
    )
    
    # Scan ALL SQL files recursively in the entire snowflake package
    for sql_file in snowflake_path.rglob("*.sql"):
        # Skip test files
        if 'test' in str(sql_file).lower():
            continue
            
        with open(sql_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        for match in macro_pattern.finditer(content):
            full_macro = match.group(1)
            macro_name = match.group(2)
            
            # We'll include all macros, but mark which ones are dispatched
            is_dispatched = macro_name.startswith('snowflake__')
            
            macros.append({
                'name': macro_name,
                'content': full_macro,
                'file': sql_file.relative_to(snowflake_path),
                'is_dispatched': is_dispatched
            })
    
    # Remove duplicates
    seen = set()
    unique_macros = []
    for macro in sorted(macros, key=lambda x: x['name']):
        if macro['name'] not in seen:
            seen.add(macro['name'])
            unique_macros.append(macro)
        else:
            print(f"Duplicate macro found: {macro['name']} in {macro['file']}")
    
    return unique_macros

def convert_macro_to_oef(macro_info):
    """Convert a snowflake__ macro to oefsnowflake__ version."""
    content = macro_info['content']
    name = macro_info['name']
    
    if macro_info['is_dispatched']:
        # For dispatched macros (snowflake__xxx), convert to oefsnowflake__xxx
        converted = re.sub(
            r'{%\s*macro\s+snowflake__' + re.escape(name[11:]),  # Remove 'snowflake__' prefix
            '{% macro oefsnowflake__' + name[11:],
            content,
            count=1
        )
    else:
        # For helper macros, keep the same name
        converted = content
    
    # Within the macro body, replace any calls to other snowflake__ macros
    # with oefsnowflake__ versions
    converted = re.sub(
        r'\bsnowflake__(\w+)\b',
        r'oefsnowflake__\1',
        converted
    )
    
    return converted

def generate_delegates_file(output_path=None):
    """Generate the complete delegation file with actual implementations."""
    if output_path is None:
        # Default path relative to the script location
        script_dir = Path(__file__).parent
        output_path = script_dir.parent / "python_package" / "dbt-oefsnowflake" / "dbt" / "include" / "oefsnowflake" / "macros" / "snowflake_delegates.sql"
    
    macros = extract_snowflake_macros()
    
    if not macros:
        print("No Snowflake macros found!")
        return
    
    # Group macros by category based on file path
    categories = {}
    for macro in macros:
        category = str(macro['file']).split(os.sep)[1] if len(str(macro['file']).split(os.sep)) > 1 else 'general'
        if category not in categories:
            categories[category] = []
        categories[category].append(macro)
    
    # Generate the file content
    lines = [
        "{#-- AUTO-GENERATED FILE - DO NOT EDIT MANUALLY --#}",
        "{#-- Generated by update_macro_delegates.py --#}",
        "{#-- This file contains oefsnowflake versions of all dbt-snowflake macros --#}",
        "",
        "{#-- To regenerate this file, run: python scripts/update_macro_delegates.py --#}",
        "",
        "",
        "{#-- BASE DISPATCHER MACRO --#}",
        "{#-- This is needed because dbt core calls list_relations_without_caching directly --#}",
        "{% macro list_relations_without_caching(schema_relation) %}",
        "  {{ return(adapter.dispatch('list_relations_without_caching', 'dbt')(schema_relation)) }}",
        "{% endmacro %}",
        ""
    ]
    
    # Generate macros by category
    for category, category_macros in sorted(categories.items()):
        # Separate dispatched and helper macros
        dispatched = [m for m in category_macros if m['is_dispatched']]
        helpers = [m for m in category_macros if not m['is_dispatched']]
        
        if dispatched:
            lines.append(f"\n{{#-- {category.upper()} DISPATCHED MACROS --#}}")
            for macro in dispatched:
                lines.append("")
                lines.append(f"{{#-- From: {macro['file']} --#}}")
                lines.append(convert_macro_to_oef(macro))
        
        if helpers:
            lines.append(f"\n{{#-- {category.upper()} HELPER MACROS --#}}")
            for macro in helpers:
                lines.append("")
                lines.append(f"{{#-- From: {macro['file']} --#}}")
                lines.append(convert_macro_to_oef(macro))
    
    # Write the file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    
    print(f"Generated {len(macros)} macro implementations in {output_path}")
    print(f"Categories: {', '.join(sorted(categories.keys()))}")
    
    # Show some statistics
    total_lines = sum(macro['content'].count('\n') for macro in macros)
    print(f"Total lines of macro code: {total_lines}")

if __name__ == "__main__":
    generate_delegates_file()